package de.culture4life.luca.testing.provider.opentestcheck;

import com.google.android.gms.common.util.Hex;

import android.net.Uri;
import android.util.Base64;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.nexenio.rxkeystore.RxKeyStore;
import com.nexenio.rxkeystore.provider.hash.RxHashProvider;
import com.nexenio.rxkeystore.provider.hash.Sha256HashProvider;

import de.culture4life.luca.registration.RegistrationData;
import de.culture4life.luca.testing.TestResultParsingException;
import de.culture4life.luca.testing.TestResultVerificationException;
import de.culture4life.luca.testing.provider.TestResultProvider;

import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.X509EncodedKeySpec;

import androidx.annotation.NonNull;
import io.reactivex.rxjava3.core.BackpressureStrategy;
import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.core.Single;

import static de.culture4life.luca.testing.TestResultVerificationException.Reason.INVALID_SIGNATURE;
import static de.culture4life.luca.testing.TestResultVerificationException.Reason.NAME_MISMATCH;

public class OpenTestCheckTestResultProvider extends TestResultProvider<OpenTestCheckTestResult> {

    private static final String URL_PREFIX_TESTVERIFY_IO = "https://testverify.io/v1#";
    private static final String URL_PREFIX_SODA = "https://app.soda-software.de/result/";
    private static final RxHashProvider HASH_PROVIDER = new Sha256HashProvider(new RxKeyStore());
    protected static final String ENCODED_TICKET_IO_PUBLIC_KEY = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqImfTl5rpFHeCM/cjAgeMS8mfhxGxO3+dss+1jidKRJ7ta2fOIQ6k1wPLtqh8U2HHIITXY8Atrlh81s9bSGeJIL9VY/QDeJgqwU147eDLqpO/iF4LvKa13bats+WzN2vXU9vPtk3WNRXh5SktbdMnmK49l20TgjzPac1ES3tv7MSExeF6Bq9zPrG47mUJW+Fm8AH7nID5kBYFosMcsRNVmY4PNYCYM7q17Cc/S/MjFZD+f4mzYLRnMbZs7IjLBGlrood21XHTNt1G6/1f4peA6EWCgKbCgbwdCIHl/wn/ktWOjxoAogX3oRcKOhhCcgt+7ReY8mj2exrTypmN3TscQIDAQAB";
    protected static final String ENCODED_SODA_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAu7TJ7bLhg3tvgXwnnTx8IFL80/qGDIuctJR/HN0EzooYooMJi0tauRvokbKOqZ40bPahOUMZheeaueKkzSEyfjqPAXOSNzBe9ltgHQcDWjKUuMIaTJW5w2nJncR5UAOFmuqY8aL5IInu/vVgTjP/mXqWN5JKiEGpA3R7UNn0RWFdU6HJ4qq1n52hyUNFF4bRTQHqkw3fnJEMTOqubo4StBX2GMO8F/pCn4UA8+nhzHbtvE1QE4R+ibxs2zbGwDFL5EFDdbqvLULeMfSys5pUDgx7z04oaSzh/MYvtApqOv3dxHi8HkBlCXNUMjUD6EWukcWn4IFHC9MAKzYq4JcfANNjka5ug5LUuL84GcITKqeesZzbSSUU3/OTRk4yri7QbbNKfbv3+E9rUpcQhVTVNdBo3jxqmCm25GjwmYWTLE9++UT4IiUid3Y6kAC+Xeiz2Q+9bXszj6tME1WrhKCAc6dvM6vM3neYul5xnI/K1CSq7lB8KDxCS1//7FT6EIDa4+UVSONkTrVzaVexQgt/fMO3c5TadjS8KN3Gml0DIhzahAXzp+CJ+0xgQqsTcoujRfnVCw2d3YLP6x8JKG4vPikYUhOJ1NEBuAJv1Ict1uFuIoClaw1TkoDeUU4rPcemSOb3JXRKZeIQrRGU9vOzNVfCViDYkiE3X/IbmedhTEUCAwEAAQ==";
    protected static final String ENCODED_MEIN_CORONA_TEST_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAqefCWY5KQ6K6KYI4ioALntTWIXOpL5HU4Obh645VIY9q2gFl959I2XzNvKhqMNgvlbj91bY0Y8vQmGVVKyJs9BvKNi9TmjGBU6Jn88TP//jmi4K24QQ+PeqT2O+Jz8wnhQoW/tf9TJa7In31HJcDWkLK7USrLPyRL4vaosOPcBIRTCK0KrjZbEYikXBotiXHUIGNmlRRJzOoWYB8asDVDT+3GTKMXvOxIxRebdvkmRRUl0Wl/+oKlit6fN8XmgGxiJtFVaWMI0dec+afPJwmoGrNSiX9WlvV37x0qefWOc8AGauQ7HxmCq+RK7qz6+cRvo1xEXKcw/GDiXXKwZpOcBUogNee4fDR+WoF8auoCyisRKkqCFqZh09A8goiV3aqAK2JYNxgULoYZ/1BnFX/zldpD6PY+UGcb8RErfXs4Lj88bEBlm/aOs3n4N5yt3866ylOMofLFA2nl27857s/wwFpF0uD8AlBy3GynNFOLxOsCrnZULs/ipZbiBtmX5x71kydOldoQQF+Yrc1XKqZ62+MK9xIQIcvKk/azb7LGG8SWiHW4EbvmPzPSP6QqZslfLRbXcpc8g4ZCRNYHAfNGPwxqjQRNwTKYwPK4lFjqoI3dVrkCVI1hfEpXdBKBQ5TientoC82eeitiFaQIG5yXNnWAmf3gxDX4AltBsVafLsCAwEAAQ==";
    protected static final String ENCODED_DM_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA2Qg6eu+5MLfs8XZosUUOyHenh51zI4RtaXrHdNhVpHiadTO48rQU9GvDJIM6qoNFWtWMak+kvxp9qYQrCtt7YoL74GagTxhK9g4wOvBV/8AYW/asSRslpFhNi0nlKujiSdf9aKlmUouRSYO200+/8XFz+YRYhL31Srv8xEAuHjLk2wI4/d56FkjMWOxMV7aO4ClicR8WfUZzod779VpCtZY6kkhHLppQ2elLviK2SX5WjPq6srWgCYi3B0aWb/qvM1/gMs7/T/zz9WXJJeMCpElcRWVtbmYsn12wx1hZtn9RdlfpVFnQCbE8WvcvttqPspr2Z0TLgusO+1z7RiayqHVM+ai5uoAOptq4LwkJ6Hls2Aaa9+fx58lrtZ6QCK2J8aSY8z59NFeRJUMfZmTffYNG4gR9rE0hNe+u1Tg+HfFHLpPM62u3D1eCkzw7OlBaRUVlYL7LLir+WT5LP7sL2DaY2WauK6QSI603sO14c3Y8upX3SySLfjryPctzOXv0oH0RG/M2YAbX9KEImw9cYrEJjx7H9tL7QEQ1ufTh2aIeB66uiTV/Ek/lCiVuGefI2Eg0dR3iiuWXfxoqJN8f1KZoaKeIAK6V2Zf+EG15R6ClEqobGryGvcoKfpeJe0KaQSsDQ2RuveGff8Wz6qbPwu9Jvb2i++mfx1Nr22ubjwsCAwEAAQ==";
    protected static final String ENCODED_TEST_NOW_PUBLIC_KEY = "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA2f7iILA7fFDXXjZSdVknvahoMrmExeB5S06E4KXKUogpkoe6AlkEQJJUhqmUrbIGBsrcSj09rz8WbArXRkGXp3WZELl4kOK/441KW5HAA9hXlXyrgdajCKfofg5CdaXhlvMotL2wBa7JKg/jCy/q1jFS78s8AzrU/CMQ/3w1PCAdRmiOpVLqz66D6+fliAz11Om8GLQUR6S9HN00hI00waxbTGwQ2d8bzXyF2V8hNa2Z3IdYkacvLRnEe4Lr66E0mqzLM0I+H12I23tiC0l7Pw/Nt8KD40zHbwfzuVQ+2K4cazsB3PJInl8HR5n2lqrTxTutm/NQGngtDWxVptnbdqDszrPGsS8OvJmt7cBWJDIV3bMvAmWW9IY3OLj8S707Cx/OETBj2d+nEbyNM2Kb9GLsYwTBIwZHmAo//uYjCyAVXgLnWyN495JZWKPJSsbSpjckqElfOVouJ+wqR+emjCRjOa5o2XH+iU+Aqca8o9c6yO8IxNkKuxTJuZri6rB3hqz3DT9GuRSI7UYHnisYeXAS1OPcEirqZrFP3jqeDaY8tCTtocqNsKD15oLLpFJrhhIG0Y2UwIY2f+WQflh9ySxtjmRGHArmWobmaBiKG0DcycD4nPbJbiNOwWRpWC0JNh6QzreAb2kxsc1rhFOATVMnSOJij3CQPgKi0+GdFmECAwEAAQ==";

    private RSAPublicKey ticketIoKey;
    private RSAPublicKey sodaKey;
    private RSAPublicKey meinCoronaTestKey;
    private RSAPublicKey dmKey;
    private RSAPublicKey testNowKey;

    @Override
    public Single<Boolean> canParse(@NonNull String encodedData) {
        return getEncodedJwtWithoutUrl(encodedData)
                .map(JWT::decode)
                .map(decodedJWT -> true)
                .onErrorReturnItem(false);
    }

    @Override
    public Single<OpenTestCheckTestResult> parse(@NonNull String encodedData) {
        return getEncodedJwtWithoutUrl(encodedData)
                .map(OpenTestCheckTestResult::new)
                .onErrorResumeNext(throwable -> Single.error(new TestResultParsingException(throwable)));
    }

    @Override
    public Completable validate(@NonNull OpenTestCheckTestResult testResult, @NonNull RegistrationData registrationData) {
        return Completable.mergeArray(
                verifyJwt(testResult.getLucaTestResult().getEncodedData()),
                verifyNameHash(testResult.n, registrationData)
        );
    }

    private Completable verifyJwt(@NonNull String jwt) {
        return Maybe.mergeDelayError(getPublicKeys()
                .map(publicKey -> verifyJwt(jwt, publicKey)
                        .andThen(Maybe.just(publicKey))
                        .onErrorResumeWith(Maybe.empty()))
                .toFlowable(BackpressureStrategy.BUFFER))
                .firstOrError()
                .ignoreElement()
                .onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(INVALID_SIGNATURE, throwable)));
    }

    private Completable verifyJwt(@NonNull String jwt, @NonNull RSAPublicKey publicKey) {
        return Completable.fromAction(() -> {
            Algorithm algorithm = Algorithm.RSA256(publicKey, null);
            JWTVerifier verifier = JWT.require(algorithm).build();
            verifier.verify(jwt);
        }).onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(INVALID_SIGNATURE, throwable)));
    }

    private Completable verifyNameHash(@NonNull String expectedNameHash, @NonNull RegistrationData registrationData) {
        return generateNameHash(registrationData)
                .flatMapCompletable(actualNameHash -> Completable.fromAction(() -> {
                    if (!actualNameHash.equals(expectedNameHash)) {
                        throw new IllegalArgumentException("Name hash mismatch");
                    }
                })).onErrorResumeNext(throwable -> Completable.error(new TestResultVerificationException(NAME_MISMATCH, throwable)));
    }

    private Single<String> generateNameHash(@NonNull RegistrationData registrationData) {
        return Single.fromCallable(() -> {
            String name = registrationData.getFirstName() + registrationData.getLastName();
            name = name.toUpperCase();
            name = name.replaceAll("[^\\x00-\\x7F]", "");
            name = name.replaceAll("/[^\\x41-\\x5A]/", "");
            return name.getBytes(StandardCharsets.US_ASCII);
        }).flatMap(HASH_PROVIDER::hash).map(Hex::bytesToStringLowercase);
    }

    private Single<String> getEncodedJwtWithoutUrl(@NonNull String encodedData) {
        return Single.fromCallable(() -> {
            if (encodedData.startsWith(URL_PREFIX_TESTVERIFY_IO)) {
                return encodedData.substring(URL_PREFIX_TESTVERIFY_IO.length());
            } else if (encodedData.startsWith(URL_PREFIX_SODA)) {
                Uri uri = Uri.parse(encodedData);
                return uri.getQueryParameter("data");
            } else {
                return encodedData;
            }
        });
    }

    private Observable<RSAPublicKey> getPublicKeys() {
        return Single.mergeArray(
                getTicketIoKey(),
                getSodaPublicKey(),
                getMeinCoronaTestPublicKey(),
                getDmPublicKey(),
                getTestNowPublicKey()
        ).toObservable();
    }

    private Single<RSAPublicKey> getTicketIoKey() {
        return Maybe.fromCallable(() -> ticketIoKey)
                .switchIfEmpty(decodePublicKey(ENCODED_TICKET_IO_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.ticketIoKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getSodaPublicKey() {
        return Maybe.fromCallable(() -> sodaKey)
                .switchIfEmpty(decodePublicKey(ENCODED_SODA_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.sodaKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getMeinCoronaTestPublicKey() {
        return Maybe.fromCallable(() -> meinCoronaTestKey)
                .switchIfEmpty(decodePublicKey(ENCODED_MEIN_CORONA_TEST_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.meinCoronaTestKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getDmPublicKey() {
        return Maybe.fromCallable(() -> dmKey)
                .switchIfEmpty(decodePublicKey(ENCODED_DM_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.dmKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> getTestNowPublicKey() {
        return Maybe.fromCallable(() -> testNowKey)
                .switchIfEmpty(decodePublicKey(ENCODED_TEST_NOW_PUBLIC_KEY)
                        .doOnSuccess(decodedPublicKey -> this.testNowKey = decodedPublicKey));
    }

    private Single<RSAPublicKey> decodePublicKey(@NonNull String encodedPublicKey) {
        return Single.fromCallable(() -> {
            byte[] encoded = Base64.decode(encodedPublicKey, Base64.NO_WRAP);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(encoded));
        });
    }

}
